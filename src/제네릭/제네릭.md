
# 제네릭 클래스와 제네릭 인터페이스

- 다양한 클래스와 인터페이스를 내부 멤버에서 활용하는 클래스를 작성하고자 할 때는 제공되는 클래스나 인터페이스
의 다양성 만큼이나 많은 가짓수의 클래스를 생성해야 한다. 이러한 비효율성을 한 번에 해결하는 데 필요한 문법 요소가
**제네릭**이다.

[제네릭 이전 Object를 사용하여 해결하는 방법]
필드를 모든 자바 클래스의 최상위 클래스인 Object 타입으로 선언하는 것이다. Object 객체를 저장하고 관리하는
클래스를 생성하면 사과이든 연필이든 저장하거나 읽을 수 있을 것이다.
단, 데이터를 저장할 때는 상관없지만 저장된 데이터를 각가의 타입으로 꺼내오기 위해선 저장된 형태로 캐스팅해야 한다.
필드 자체가 Object 타입이기 때문에 get() 메서드로 가져오는 타입 또한 항상 Object 타입이기 때문이다.

 
# 제네릭의 문법
제네릭을 사용하면 모든 타입의 상품을 저장할 수 있으면서도 잘못된 캐스팅을 할 때 문법 오류를 발생시켜 잘못된 캐스팅
으로 발생할 수 있는 문제를 사전에 예방할 수 있다. 이를 **강한 타입 체크**라고 한다. 

  - ## 제네릭 클래스와 제네릭 인터페이스 정의하기

    - ### 제네릭 타입 변수명이 1개일 때

      접근 지정자 class 클래스명(인터페이스명)<T> {
          // 타입 T를 사용한 코드
      }

    - ### 제네릭 타입 변수명이 2개일 때

    접근 지정자 class 클래스명(인터페이스명)<K, V> {
        // 타입 K, V를 사용한 코드
    }

    여기서 제네릭 타입 변수명은 사용자가 임의로 지정할 수 있지만 일반적으로 영문 대문자 한글자를 사용한다.
   - ### 관례적 제네릭 타입 변수명
    T :  타입
    K : 키
    V : 값
    N : 숫자
    E : 원소

  - ## 제네릭 클래스의 객체 생성

    1. 클래스명<실제 제네릭 타입> 참조 변수명 = new 클래스명 <실제 제네릭 타입>();
    2. 클래스명<실제 제네릭 타입> 참조 변수명 = new 클래스명<>();

    **제네릭 타입을 생략할 경우 최상위 클래스인 Object로 처리된다**


# 제네릭 메서드

  - ## 제네릭 메서드 내에서 사용할 수 있는 메서드
  **제네릭 메서드의 내부에서는 아직 확정되지 않은 제네릭 타입 객체의 멤버 중 Object에서 물려받은 메서드만 사용할 수 있다.**


# 제네릭 타입 범위 제한

  - ## 제네릭 타입 범위 제한의 필요성
  사과, 배, 딸기 등은 과일 클래스를 상속해 만든 클래스이고 연필, 지우개, 볼펜 등은 문구 클래스를 상속받은 자식 클래스이다.
  이때 과일의 종류만 저장 및 관리하는 제네릭 클래스를 생성하고 싶을 때 사용하는 것이 **제네릭 타입의 범위 제한**이다.

  이렇게 했을 때 얻을 수 있는 다른 장점은 **제한된 제네릭 메서드 내부에서 사용할 수 있는 객체 의 메서드 종류** 이다.
  이전에 알아본 것처럼 제네릭 타입 변수가 이후에 어떤 타입으로 지정될 지 모르기 때문에 Object 클래스의 메서드만 사용할 수 있었다.

  - ## 제네릭 타입 점뷔 제한의 종류와 타입 범위 제한 방법

    - 제네릭 클래스의 타입 제한
        접근 지정자 class 클래스명 <T extends 최상위 클래스/인터페이스명> {
    }

    - 제네릭 메서드의 타입 제한
        접근 지정자 <T extends 최상위 클래스/인터페이스명> T 메서드명(T t) {
    }

  - ## 메서드 매개변수일 때 제네릭 클래스의 타입 제한
    - 제네릭 클래스 객체의 제네릭 타입
    1. 
    리턴 타입 메서드명(제네릭 클래스명<제네릭 타입명> 차조 변수명) {
    }
    2. 
    리턴 타입 메서드명(제네릭 클래스명<?> 참조 변수명) {
    }
    3.
    리턴 타입 메서드명(제네릭 클래스명<? extends 상위 클래스/인터페이스> 참조 변수명) {
    }
    4.
    리턴 타입 메서드명(제네릭 클래스명<? super 하위 클래스/인터페이스> 참조 변수명) {
    }

# 제네릭의 상속

부모 클래스가 제네릭일 때 자식 클래스 또한 제네릭 클래스가 된다. 제네릭 타입 변수를 자식 클래스가 그대로 물려받게 되고 제네릭 타입 변수를 추가해 정의할 수도 있다.


    


